---
layout: post
comments: true
title: "Invoking .NET from Ruby"
---

# Invoking .NET from Ruby

## Why I do it

From time to time you may find yourself with the need to call into .NET from Ruby. Personally, I find myself doing so in my automation test 
suites for .NET applications that we drive using `cucumber` and [`mohawk`](https://github.com/leviwilson/mohawk). 
Generally I do so in either some setup or cleanup hooks with `cucumber` if I need to do something outside of the UI. [`RAutomation`](https://github.com/jarmo/RAutomation) 
itself (the underlying driver for `mohawk`) makes use of this technique to hook into [Microsoft UI Automation](http://msdn.microsoft.com/en-us/library/ms747327.aspx) 
to drive Windows applications from ruby. In this post I will go over the way in which we can set this up.

## Moving Parts

There are a couple of manners in which you can achieve this. One is using something like [`IronRuby`](https://ironruby.codeplex.com/), which is a .NET implementation of the 
ruby programming language, but this seemed like overkill for my needs. Additionally, development on IronRuby seems to have been non-existent for a few years and there are limitations as to what version of ruby that you can use with it.

Another manner is to use a Managed C++ DLL as a wrapper and calling into it using the [`Ruby-FFI`](https://github.com/ffi/ffi) gem. This is the technique that we will be discussing in this article.

## The Wrapper

### Creating the Project

The managed C++ DLL is used to interface with ruby. To get your basic "Hello World" project setup, simply use Visual Studio to create a new C++ -> CLR project.

![C++ .NET CLR Project](/images/dotnet_new_project.png)

This will generate a C++ CLR library project that looks like the following:

```
.
│   .gitattributes
│   .gitignore
│   Hello.Net.FromRuby.sln
│
└───Hello.Net.FromRuby
        app.ico
        app.rc
        AssemblyInfo.cpp
        Hello.Net.FromRuby.cpp
        Hello.Net.FromRuby.h
        Hello.Net.FromRuby.vcxproj
        Hello.Net.FromRuby.vcxproj.filters
        ReadMe.txt
        resource.h
        Stdafx.cpp
        Stdafx.h
```

By default, this will create a manged C++ library project with nothing in the `Hello.Net.FromRuby.h` and `Hello.Net.FromRuby.cpp` with a managed class definition in it.

### Hello World

To get our "Hello, world!" application rolling, we simply need to export a method that we will be able to call from ruby. Modify the `.h` and `.cpp` files to look like the following:

```c++
// Hello.Net.FromRuby.h
#pragma once

using namespace System;

extern "C" {
  _declspec(dllexport) void Hello_DotNet_FromRuby(const char* message);
}
```

```c++
// Hello.Net.FromRuby.cpp
#include "stdafx.h"

#include "Hello.Net.FromRuby.h"

void Hello_DotNet_FromRuby(const char* toWhom) {
  Console::WriteLine("Hello, {0}!", gcnew String(toWhom));
}
```

In order to call into our exported method from ruby, we will need to setup `ffi` like the following:

```ruby
# hello_dotnet_fromruby.rb
require 'ffi'

module Library
  extend FFI::Library

  ffi_lib File.join(File.dirname(__FILE__), 'Debug/Hello.Net.FromRuby.dll')

  attach_function :hello, :Hello_DotNet_FromRuby, [:string], :void
end
```

After you've saved `hello_dotnet_fromruby.rb` you can run it in `irb` like so:

```
>> irb
irb(main):001:0> load 'hello_dotnet_fromruby.rb'
=> true
irb(main):002:0> Library.hello 'World'
Hello, World!
=> nil
irb(main):003:0>
```

And BAM! We are calling `Console::WriteLine` from ruby. Wasn't that simple?

## C++ Runtime Dependency
If you are trying to run this on another machine, you may have seen the following error message when you tried to load the file:

```
irb(main):002:0> load 'hello_dotnet_fromruby.rb'
LoadError: Could not open library './Debug/Hello.Net.FromRuby.dll': The specified module could not be found.

        from C:/Ruby193/lib/ruby/gems/1.9.1/gems/ffi-1.9.0-x86-mingw32/lib/ffi/library.rb:123:in `block in ffi_lib'
        from C:/Ruby193/lib/ruby/gems/1.9.1/gems/ffi-1.9.0-x86-mingw32/lib/ffi/library.rb:90:in `map'
        from C:/Ruby193/lib/ruby/gems/1.9.1/gems/ffi-1.9.0-x86-mingw32/lib/ffi/library.rb:90:in `ffi_lib'
        from hello_dotnet_fromruby.rb:6:in `<module:Library>'
        from hello_dotnet_fromruby.rb:3:in `<top (required)>'
        from (irb):2:in `load'
        from (irb):2
        from C:/Ruby193/bin/irb:12:in `<main>'
irb(main):003:0>
```

One of two things can be causing this. Either the actual path to the `Hello.Net.FromRuby.dll` is not actually there, or the machine that you're running this on does not have the Microsoft C++ Runtime installed. If you built the DLL with Visual Studio 2012, you will need the [C++ 2012 Runtime Redistributable](http://www.microsoft.com/en-us/download/details.aspx?id=30679), if you built it with Visual Studio 2010 you will need the [C++ 2012 Runtime Redistributable](http://www.microsoft.com/en-us/download/details.aspx?id=5555) installed.

## FFI Tips & Tricks
The initial `"Hello, World!"` function isn't terribly interesting. It's a `void` method that takes a `const char*` type and prints it out. Most of the time we will 
want to return more interesting information than this. For me, I have found that returning C++ `struct` pointers to be the easiest way to manage the information that 
we are returning information into ruby from C++. Using a `struct` makes memory management much simpler in my opinion. Let's take a look at setting this up.

### Defining Your `struct`
First, we will setup our `struct` on the C++ side of things. We will define a `struct` that returns a grab-bag of information. Here is what this looks like:

```cpp
// MyStruct.h

#pragma once

#include "Stdafx.h"
#include "StringHelper.h"

using namespace System;

typedef struct _MyStruct {
  bool IsMale;
  int Age;
  char* Name;
  char** Languages;
  int LanguagesLength;

  _MyStruct(bool isMale, int age, String^ name, ...array<String^>^ languages) {
    IsMale = isMale;
    Age = age;
    Name = StringHelper::ToUnmanaged(name);

    if( languages->Length > 0 ) {
      Languages = new char*[languages->Length];
      LanguagesLength = languages->Length;
    }

    auto languageIndex = 0;
    for each(auto language in languages) {
      Languages[languageIndex++] = StringHelper::ToUnmanaged(language);
    }
  }

} MyStruct, *MyStructPtr;
```

We have defined a constructor for the `MyStruct` `struct` that takes in all of the information that we need. Note that we can use .NET types in this, but we need to map 
these back to C++ constructs. I've also included a `StringHelper` class definition that maps between .NET `String^` types and `char *` types.

```cpp
#pragma once

#include "Stdafx.h"
#include <string>

using namespace System::Runtime::InteropServices;

ref class StringHelper
{
public:
  static void CopyToUnmanagedString(String^ source, char* destination, const int destinationSize)
  {
    auto unmanagedString = Marshal::StringToHGlobalAnsi(source);
    strncpy_s(destination, destinationSize, (const char*)(void*)unmanagedString,  _TRUNCATE);
    Marshal::FreeHGlobal(unmanagedString);
  }

  static char* ToUnmanaged(String^ source)
  {
    if( nullptr == source ) return NULL;

    const int numberOfBytes = source->Length + 1;
    auto unmanagedString = new char[numberOfBytes];
    CopyToUnmanagedString(source, unmanagedString, numberOfBytes);
    return unmanagedString;
  }
};
```

To use this, let's export another method from our DLL.

```cpp
// ... Hello.Net.FromRuby.h
__declspec(dllexport) MyStructPtr Get_Information();
// ...

// ... Hello.Net.FromRuby.cpp
_declspec(dllexport) MyStructPtr Get_Various_Information() {
  return new MyStruct(true, 34, "Joe Johnston", "English", "Spanish", "Danish");
}
// ...
```

Let's see what this looks like on the `FFI` side of things.

```ruby
module Library
  class MyStruct < FFI::Struct

    # this layout needs to match exactly with the C++ side
    layout :is_male, :bool,
           :age, :int,
           :name, :string,
           :languages, :pointer,
           :number_of_languages, :int

    def male?
      self[:is_male]
    end
    
    def age
      self[:age]
    end
    
    def name
      self[:name]
    end
    
    def languages
      # read the char ** individually
      self[:number_of_languages].times.collect do |index|
        pointer = (self[:languages] + (index * FFI::Type::POINTER.size)).read_pointer
        pointer.read_string
      end
    end
    
    end
  end
    
  attach_function :get_information, :Get_Various_Information, [], MyStruct.by_ref
end
```

After everything is wired up correctly, we should be able to invoke the method now from `irb`.

```
>irb
irb(main):001:0> load 'hello_dotnet_fromruby.rb'
=> true
irb(main):002:0> info = Library.get_information
=> #<Library::MyStruct:0x2a585a8>
irb(main):003:0> info.methods
irb(main):004:0> info.male?
=> true
irb(main):005:0> info.age
=> 34
irb(main):006:0> info.languages
=> ["English", "Spanish", "Danish"]
```

### Memory Management
You may have noticed a slight problem with our implementation. Where is the memory management? We're allocating memory on the C++ side of things not only for the 
`MyStruct struct`, but even within the `struct` we are allocating memory for the `Name` field as well as any `n` number of languages that were passed into the constructor. 
Luckily, `FFI` has a nice way to manage this with an `FFI::ManagedStruct`. With the `FFI::ManagedStruct`, you simply define a `self.release` method that will get called 
when the ruby object gets garbage collected. You just provide a C++ method to call when this happens that knows how to free up your memory.

In the example above, here is how we would augment the `MyStruct` class on the ruby side to handle this:

```ruby
module Library
  class MyStruct > FFI::ManagedStruct
    # ... same layout as above
    
    def self.release(pointer)
      Library.release_my_struct(pointer)
    end
  end

  attach_function :release_my_struct, :Release_MyStruct, [:pointer], :void
end
```

```cpp
// ...
// Hello.Net.FromRuby.h
__declspec(dllexport) void Release_MyStruct(MyStructPtr myStruct);

// Hello.Net.FromRuby.cpp
void Release_MyStruct(MyStructPtr myStruct) {
  delete myStruct;
}
// ...
```

```cpp
// MyStruct.h
typedef struct _MyStruct {
  // ...
  ~_MyStruct() {
    delete[] Name; // free up the Name char *

    // free up each language char *
    for(auto whichLanguage = 0; whichLanguage < LanguagesLength; ++whichLanguage) {
      delete[] Languages[whichLanguage];
    }

    delete[] Languages; // free up the char **
  }
} MyStruct, *MyStructPtr;
```

If you'd like, put some `Console::WriteLine` statements in the `~_MyStruct` destructor. When you call the `Library.get_information` from `irb`, when ruby garbage collects 
the returned objects, you will see your print messages getting dumped out to the screen when `self.release` is called.

### Unit Testing / Memory
Though it is pretty straightforward to add memory management, admittedly it is something that I tend to forget when I'm wiring up my library to `FFI`. Additionally, it felt 
a little dirty to me that we don't have any unit tests for our application. With this, we can kill two birds with one stone. Luckily there are a couple of really good 
testing frameworks for C++. Two of my personal favorites are `CppUTest` (written by [James Grenning](http://twitter.com/jwgrenning)) and `gtest` and `gmock` (maintained by Google). Both are really solid testing frameworks and fortunately we can test our memory usage with it to make sure we are not being jerks with it. Both frameworks have a similar style to define tests, in this post I will talk about how to test using `gtest`.

### Exception Handling

## Using C# for Implementation


